<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="description" content="Diagramming basedd on an open repository of prototype structures.">
<title>PrototypeJungle</title>
<link rel="stylesheet" type="text/css"  href="style.css"/>
<link rel="stylesheet" type="text/css"  href="spectrum.css"/>
<link rel="icon" href="/images/favicon.ico" />

<style>
	.theGrid {
		display:grid;
		padding-top:10px;
		grid-template-columns:1fr 4fr 1fr;
	}
  .indent {
		padding-left:20px;
	}
  .codeVar {
		font-style:italic;
	}  
  
  .textVar {
		font-weight:bold;
    font-size:12pt
	}
  .title {
		font-weight:bold;
    font-size:16pt;
    text-align:center;
	}
 .section {
		font-weight:bold;
    font-size:14pt;
	}
</style>
</head>
<body style="background-color:white;font-size:14pt"> 
<div class="theGrid">
<div></div>
<div>

<p> This module will be introduced via annotated code, which generates the image</p>
 <p><img  src="/doc/drop_ice.jpg?alt=media" style="bborder:thin black solid;cursor:pointer"  width="400" height="400" max-height="500"/></p>
 <p>Here's the code:</p>
<pre style="padding-left:20px;font-size:10pt;font-weight:bold" class="code">

import {rs as linePP} from '/line/line.mjs';
import {rs as basicsP} from '/generators/basics.mjs';
import {rs as addDropMethods} from '/mlib/drop.mjs';
import {rs as addSegsetMethods} from '/mlib/segsets.mjs';
let rs = basicsP.instantiate();

addDropMethods(rs);
addSegsetMethods(rs);
rs.setName('drop_ice');
let wd = 200;

let topParams = {width:wd,height:wd,dropTries:100,lineLength:2,frameStroke:'rgb(2,2,2)',framePadding:20,frameVisible:0,minSeparation:10}

Object.assign(rs,topParams);


rs.initProtos = function () {
	this.lineP = linePP.instantiate();
	this.lineP.stroke = 'yellow';
	this.lineP['stroke-width'] = .3;
}  

rs.initialDrop= function () {
  let {width,height} = this; 
  // the rectangleSegments method is defined in the segsets module
  let segs = this.rectangleSegments(width,height);
  let lines = segs.map((sg) => this.genLine(sg));  
  return [segs,lines];
}

rs.segParams = function () {
  let r = Math.random();
  let np = 4;
  let angle = Math.floor(r*np)* (Math.PI/np)
  let length = 2 + Math.floor(r*np)*4;
  return {angle,length};
} 

rs.dropAt = function (p) {
  let {minSeparation:sep,lineP} = this;
  let {length,angle} = this.segParams();
  let seg = this.genSegment(p,length,angle);
  let ln = this.genLine(seg,lineP);
  let eseg = this.genSegment(p,length+sep,angle);
  return [[eseg],[ln]];
}
 

rs.initialize = function () {
  core.root.backgroundColor = 'black';
	this.initProtos();
	this.generateDrop();
  	this.addFrame();

}

export {rs};


</pre>
<p> The DROP algorithm drops  things at random positions on the canvas. If a thing lands on top of another, it is thrown away, otherwise it is added.   I have used the vague word "thing". A thing is a pair [lineSegments,shapes], called a dropStruct. Often, but not always, the shapes are lines that  correspond directly to the segments in that they have the same ends; that is, they coincide geometrically. The operation</p>
<precode>
(segs,lineP) => [segs,segs.map((seg) => this.genLine(seg,LineP)]
]
</precode>

<p> will convert an array of segments into a dropStruct where this exact correspondence holds.</p> 
 
<p> As I say, lineSegments are used for detecting collisions. If a given drop does not intersect with the lineSegments already dropped, then the shapes are displayed (by adding them to the shape tree).
 The segsets method library is used to build sets of segments. </p>

<p>In an image generator, the  method: </p>
<preUserDefinedCode>
rs.dropAt = function (p) {
...
  return [segs,shapes];
}
</precode>
<p>should be defined, where p is a Point (the "anchor point"). rs.generateDrop will call rs.dropAt  on randomly generated points p within the canvas.  </p>

<p>Parameters: rs.dropTries sets how many unsuccessful drops are tolerated before the algorithm is terminated. </p>

<p> The DROP algorithm has another mode of operation, which is deployed when the top parameter fromEnds is set.</p>

<p>In fromEnds mode, segments are dropped in such a way as to extend an already existing tree. In this mode, illustrated by the dandelion image just below, the current state consists of a tree of segments. Each segment in the tree is either interior, meaning that its end1 has been continued by one or more segments, or terminal, meaning that there is no continuing segment emerging from its end1.</p>
 <p><img  src="/doc/drop_dandelion.jpg?alt=media" style="bborder:thin black solid;cursor:pointer"  width="400" height="400" max-height="500"/></p>

<p> Here is the code:</p>
<precode>

import {rs as linePP} from '/shape/line.mjs';
import {rs as basicP} from '/generators/basics.mjs';
import {rs as addDropMethods} from '/mlib/drop.mjs';

let rs = basicP.instantiate();
addDropMethods(rs);

rs.setName('drop_dandelion');
let ht = 360;
let wd = 1* ht;


let topParams = {width:wd,height:ht,framePadding:0.15*ht,
//parameters to performDrop
dropTries:10,maxDrops:Infinity,fromEnds:1,doNotExit:[geom.Circle.mk(Point.mk(0,0),0.5*ht)],
//parameters to genFan
lineLength:5,extendWhich:'first',sepNext:0.01,splitChance:.40,splitAmount:0.05 *Math.PI,
directionChange:0.0*Math.PI,randomDirectionChange:0.025*Math.PI,lineExt:0,
// parameters to ringSeeds
numSeeds:15};

Object.assign(rs,topParams);

rs.initProtos = function () {
  this.lineP = linePP.instantiate();
  this.lineP.stroke = 'white';
  this.lineP['stroke-width'] = .5;
}

rs.initialDrop = function () {
  let rad  = 0.15 * 0.5 * this.width;
  return this.ringSeeds({stroke:'transparent',ringRadius:rad});  
}

rs.dropAt = function (p) {
  return this.genFan({startingPoint:p,stroke:'white'});
}

rs.initialize = function () {
  this.initProtos();
  this.addFrame();
  this.generateDrop();
}

export {rs};




</precode>
<p> Here is an explanation of the parameters:</p>
<p class="indent"> First, parameters to the main drop algorithm:</p>

<p class="indent"><span class = "textVar">dropTries:number</span> : if this number of consectutive drops fail due to collision, terminate the algorithm.</p>
<p class="indent"><span class = "textVar">maxDrops:number</span>: the maximum number of drop trials</p>
<p class="indent"><span class = "textVar">fromEnds:boolean</span>: run the algorithm in fromEnds mode if this value is truthy</p>
<p class="indent"><span class = "textVar">doNotExit:circle or rectangle</span>: reject drops any of whose segments straddle the inside and outside of the given geometric figure</p>
<p class="indent"> Next, parameters to genFan</p>:
<p class="indent"> Note that the generator of dropStructs, dropAt, relies on genFan to do its work:</p>:
<precode>
rs.dropAt = function (p) {
  return this.genFan({startingPoint:p,stroke:'white'});
}
</precode>
<p class="indent">genFanA, like many methods, accepts its parameters from its argument {startingPoint:p,stroke:'white'} first, and if not found there, from this (the image generator rs itself). genFan  extends the tree by either one or two segments (controlled by splitChance).  The segments, in either case, emanate from startingPoint, which will be a terminal node of the existing tree. In the latter case, it produces a branching of the tree, and in the former case not. Parameters to genFan are:</p>
<p class="indent"> <span class = "textVar">segLength:number</span>: the length of segments dropped.</p>
<p class="indent"> <span class = "textVar">startingPoint:Point</span>: the position of the terminal node to be extened. </p>
<p class="indent"> <span class = "textVar">extendWhich:string</span>: which of the terminal nodes to extend. Possible values 'first', meaning the earliest added terminal node that has not yet been extended, 'random' meaning a randomly selected terminal node, and 'last' meaning the last added terminal node.</p>
<p class="indent"> <span class = "textVar">sepNext</span>: the separation between the terminal node and the new segment(s)</p>
<p class="indent"> <span class = "textVar">splitChance</span>: the chance that a split (two segments) rather than a linear continuation (one segment), will be chosen.</p>
<p class="indent"> <span class = "textVar">splitAmount</span>: if a split is chosen, the angular difference between the two new segments.</p>
<p class="indent"> <span class = "textVar">directionChange</span>: the direction of the new segment, or center of the new branch, relative to the terminal segment being extended</p>
<p class="indent"> <span class = "textVar">randomDirectionChange</span>: a random value to be added to directionChange is chosen at random from the interval [-randomDirectionChange,randomDirectionChange]</p>
<p class="indent"> <span class = "textVar">lineExt</span>: the amount by which lineSegments should be extended to produce lines in the dropStruct. </p>

<p class="indent"> Finally , parameters to genSeeds</p>:
<p class="indent"> Note that initialDrops , relies on ringSeeds to do  its work:</p>:
<precode>

rs.initialDrop = function () {
  let rad  = 0.15 * 0.5 * this.width;
  return this.ringSeeds({stroke:'transparent',ringRadius:rad});  
}
</precode>
<p> Like genFan, ringSeeds takes its parameters first from its argument, and then from this. The parameters to ringSeeds are:</p>

<p class="indent"> <span class = "textVar">lineExt</span>: the amount by which lineSegments should be extended to produce lines in the dropStruct. </p>


</div>
</div>
</body>
</html>



