{{boilerplate1}}
<p class="title">The grid module</p>
<p> This module will be introduced via annotated code, the first batch of which generates the image</p>
 <p><img  src="/images/grid_example1.jpg?alt=media" style="bborder:thin black solid;cursor:pointer"  width="600" height="400" max-height="500"/></p>
 <p>Here's the code:</p>
<precode>
import {rs as linePP} from '/line/line.mjs';
import {rs as rectPP} from '/shape/rectangle.mjs';
import {rs as basicsP} from '/generators/basics.mjs';
import {rs as addGridMethods} from '/mlib/grid.mjs';
import {rs as addRandomMethods} from '/mlib/boundedRandomGrids.mjs';

let rs = basicsP.instantiate();
addGridMethods(rs);
addRandomMethods(rs);	
rs.setName('grid_fade');
	
rs.initProtos = function () {
	rs.rectP  = rectPP.instantiate();
	rs.rectP.fill = 'white';
	rs.rectP['stroke-width'] = 0;
	rs.rectP.width = .5;
	rs.rectP.height = .5;
  rs.blineP  = linePP.instantiate();
  rs.blineP['stroke-width'] = 0.4;
  rs.blineP.stroke = 'white';

}  

let nr = 64;
let wd = 200;
let topParams = {numRows:nr,numCols:nr,width:wd,height:wd,frameColor:'rgb(2,2,2)',pointJiggle:4,framePadding:0.15*wd,frameVisible:1};
Object.assign(rs,topParams);
</precode>
<span id="shapeGenerator"/>
<precode>
 // this method is called to populate each grid cell. 
 // in this example, the shapes generated are the little white dots.
 // The cell coordinates are given in <span class="codeVar">cell</span>. 
 // <span class="codeVar">rvs</span> are the random values generated by the <a href="/doc/boundedRandomGrids.html">boundedRandomGrids</a> module (not used in this generator)
rs.shapeGenerator = function (rvs,cell) {
	let {rectP,shapes,numRows} = this;
  let {x,y} = cell;
  let fwd = (x)/(numRows);// fraction of the way across (i.e. to max x)
  if (Math.random()&lt;fwd) {
  // the probabilty that no shape is generated grows as we move across the grid, hence the fade
    return; 
  }
  let shape = rectP.instantiate().show();
  return shape;
}
</precode>
<span id="boundaryLineGenerator"/>
<precode>
/* this method is called to draw the boundary lines. 
 Again  cell coordinates are given in <span class="codeVar">cell</span>. <span class="codeVar">rvs</span> are the random values generated by the line
   this.setupBoundaryRandomizer('v',{step:30,min:100,max:250}); 
in initialize. 
*/
rs.boundaryLineGenerator= function (end0,end1,rvs,cell) {
	let {blineP,numRows,showMissing,lines,updating,lineIndex} =this;
  let {x,y} = cell;
  let fwd = x/numRows;// fraction of the way across (i.e. to max x)
  let ra = Math.random();
  if  (ra*ra*ra&lt;fwd) {
   return;
  }
  let line = blineP.instantiate().show();
  lines.push(line);
  line.setEnds(end0,end1);
  let vi = Math.floor(rvs.v);
  // the color of the boundary line is gray,  with value generated by a boundedRandomGrid.
  line.stroke = `rgb(${vi},${vi},${vi})`; 
  return line;
}


rs.initialize = function () {
   this.setupRandomGridForBoundaries('v',{step:30,min:100,max:250}); 
   this.initProtos();
   this.addFrame();
  this.initializeGrid();
}

export {rs};
</precode>
<p> Several of the parameters in </p>
<precode>
let topParams = {numRows:nr,numCols:nr,width:wd,height:wd,frameColor:'rgb(2,2,2)',pointJiggle:4,framePadding:0.15*wd,frameVisible:1};
</precode>
need explanation. First, <span class="textVar">pointJiggle</span> , if defined and non-zero, causes
 two bounded grids to be setup via <span class="textVar">setupRandomGridForBoundaries</span>, named <span class="textVar">xJiggle</span> and <span class="textVar">yJiggle</span>. Then the points in the grid are jiggled by the amounts specified in those bounded grids. The maximum amount of jiggle is given by the <span class="textVar">pointJiggle</span> parameter. Since the grids are bounded, the amount of jiggle varies smoothly across the grid.</p>
<p>
Next, the frame parameters:  The frame facility, which draws the white rectangle around the grid, is <a href="/doc/frame.html">documented separately</a>, since the frame facility is implemented in the basics module, not the grid module, and can be used with any of the image generation modules in prototypejungle.</p>
<p> It is possible to modify the placement of grid points by defining <span class="textVar">positionFunction(i,j)</span> where <span class="textVar">i</span> is the index of the current cell in the x (width) direction,
and <span class="textVar">j</span> is its index in the y (height) direction. Here is an example:</p>

 <p><img  src="/images/grid_example2.jpg?alt=media" style="bborder:thin black solid;cursor:pointer"  width="300" height="300"/></p>
<p>and the code that produced it. Have a look at the positionFunction - the other operations we've seen before.
<precode>
import {rs as basicsP} from '/generators/basics.mjs';
import {rs as addGridMethods} from '/mlib/grid.mjs';

let rs = basicsP.instantiate();
addGridMethods(rs);
rs.setName('grid_example2');
	
rs.initProtos = function () {
  rs.blineP  = linePP.instantiate();
  rs.blineP['stroke-width'] = 0.4;
  rs.blineP.stroke = 'white';

}  

let nr = 32;
let wd = 200;
let topParams = {numRows:nr,numCols:nr,width:wd,height:wd};
Object.assign(rs,topParams);

rs.positionFunction = function(i,j) {
  let {width,height,numRows,numCols} = this;
  let cellht = height/numRows;
  let cellwd = width/numCols;
  let frd = i/numRows;  //fraction down
  let cwd = frd*width; // current width
  let ccellwd = frd*cellwd; // currect width of a cell
  let rs = Point.mk(-0.5*cwd + j*ccellwd,-0.5* height + i*cellht);;
  return rs;
 }

rs.boundaryLineGenerator= function (end0,end1,rvs,cell) {
	let {blineP,numRows,showMissing,lines,updating,lineIndex} =this;
	let line = blineP.instantiate().show();
  line.setEnds(end0,end1);
	return line;
}


rs.initialize = function () {
  debugger;
  this.initProtos();
  this.initializeGrid();
}



export {rs};
</precode>

<p>Several position functions are provided as part of the grid module.  The first is the default position function, which builds the usual sort of rectangular grid, and is installed as the initial positionFunction. The second is <span class="textVar">sidesPositionFunction</span>, in which the endpoints of  the "horizontal" (same y index)  lines are placed at even intervals on two sides, <span class="textVar">sideA</span>, and <span class="textVar">sideB</span>. 
For example the following code yields the same grid as shown immediately above.</p>

<precode>

let topParams = 
{numRows:nr,numCols:nr,width:wd,height:ht,framePadding:0.1*wd,
 sideA:geom.LineSegment.mk(Point.mk(0,-0.5*ht),Point.mk(-0.5*wd,0.5*ht)),
 sideB:geom.LineSegment.mk(Point.mk(0,-0.5*ht),Point.mk(0.5*wd,0.5*ht))
};
Object.assign(rs,topParams);

rs.positionFunction = rs.sidesPositionFunction;
</precode>

<p>in <span class="textVar">sidesPositionFunction</span>, <span class="textVar">sideA</span> and <span class="textVar">sideB</span> can also be defined by functions which take a real input in the interval [0,1] and return a point on the plane. This allows the sides to be defined as arbitrary computable curves. For example, yet another way of producing
 the above grid is:
 <precode>

 let topParams = 
{numRows:nr,numCols:nr,width:wd,height:ht,framePadding:0.1*wd,
 leftSide:geom.LineSegment.mk(Point.mk(0,-0.5*ht),Point.mk(-0.5*wd,0.5*ht)),
 rightSide:geom.LineSegment.mk(Point.mk(0,-0.5*ht),Point.mk(0.5*wd,0.5*ht)),
 sideA:function(fr) {return this.leftSide.pointAlong(fr)},
 sideB:function(fr) {return this.rightSide.pointAlong(fr)}};
Object.assign(rs,topParams);
rs.positionFunction = rs.sidesPositionFunction;
</precode>

<p>If <span class="textVar">genPoint3d</span> is defined, 
then the points on the grid (which may have been generated by a custom <span class="textVar">positionFunction</span>) are mapped into 3d via</p>
 <precode>
this.points = this.points.map((p) => this.camera.project(this.genPoint3d(p)))
 </precode>

<p>and then back.</p>
{{endplate}}


