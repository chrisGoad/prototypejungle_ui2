{{boilerplate1}}
<p class="title">dropCircles</p>

<p> This <a href="../mlib/drop.mjs">module</a> will be introduced via annotated code, which generates the image</p>
 <p><img  src="https://kingdomofpattern.com/thumbs/drop_ice.jpg?alt=media" style="cursor:pointer"  width="400" height="400"/></p>
 <p>Here's the code:</p>
<pre style="padding-left:20px;font-size:10pt;font-weight:bold" class="code">

import {rs as linePP} from '/shape/line.mjs';
import {rs as basicsP} from '/generators/basics.mjs';
import {rs as addDropMethods} from '/mlib/newDrop.mjs';
import {rs as addSegsetMethods} from '/mlib/segsets.mjs';
let rs = basicsP.instantiate();

addDropMethods(rs);
addSegsetMethods(rs);
rs.setName('drop_ice');
let wd = 100;

let topParams = {width:wd,height:wd,minSeparation:10,framePadding:20}
let dropParams = {dropTries:100,maxDrops:4000}

Object.assign(rs,topParams);

rs.initProtos = function () {
  this.lineP = linePP.instantiate();
  this.lineP.stroke = 'yellow';
  this.lineP['stroke-width'] = .15;
}  

rs.initialDrop = function () {
debugger;
  let {width,height,lineP} = this;
  let segs = this.rectangleSegments(width,height); // rectangleSegments is defined in segsets.mjs
  let lines = segs.map((sg) => this.genLine(sg,lineP));  
  return {geometries:segs,shapes:lines};
}

rs.segParams = function () {
  let r = Math.random();
  let np = 4;
  let angle = Math.floor(r*np)* (Math.PI/np)
  let length = 2 + Math.floor(r*np)*4;
  return {angle,length};
} 	

rs.generateDrop = function (p) {
  console.log('p',p);
  let p0 = Point.mk(0,0);
  let {minSeparation,lineP} = this;
  let {length,angle} = this.segParams();
  let seg = LineSegment.mkAngled(p0,angle,length);
  let line = this.genLine(seg,lineP);
  // lseg is minSeparation longer than the seg and line, meaning that lines extended by this much
  // which intersect existing dropStructs are rejected as drop candidates
  let lseg = LineSegment.mkAngled(p0,angle,length+minSeparation);
  return {geometries:[lseg],shapes:[ln]};
}
 
rs.initialize = function () {
  this.initProtos();
  this.generateDrops(dropParams);
  this.addFrame();
}

export {rs};


</precode>
 
<span class="userDefinedText">  generateDrop(p:Point)</span> returns a structure  of the form 
{geometries:arrayOf(geometricObject), shapes:arrayOf(shape)} Usually, as in this example, the shapes constitute the visible form of the geometric objects. The algorithm<span class="textVar">generateDrops</span> calls <span class="userDefinedText">  generateDrop</span> repeatedly on randomly selected points  on the canvas. It checks whether any of the geometries in the current drop collide with the set of all geometries already dropped. If so the drop is rejected. If not the geometries are added to the array of all geometries dropped so far, and the shapes are added to the visible world. Both the shapes and geometries should be returned in their zero position; <span class="textVar">generateDrops</span> moves them into position p. The <span class="textVar">generateDrops</span>reason that geometries and shapes are generated separately is that it allows the coder full control of how the geometries are made visible. The argument dropParams to <span class="textVar">generateDrops</span> has the form 
<p> The circleDrop algorithm drops  circles at random positions on the canvas. If a circle lands on top of another, it is thrown away, otherwise it is added.   
If defined, <span class="userDefinedText">this.generateDrop(p:Point)</span>  computes whatever properties are of interest, for example radius or fill, and should return an object with those properties. If the drop passes the no-intersection test, it is added to the  drop array (the point at which it was dropped is added by the <span class="textVar">generateCircleDrops</span> method).   If <span class="userDefinedText">this.generateDrop</span> returns a null value, no drop attempt is made. If <span class="userDefinedText">this.generateDrop</span> is not defined,  then  the radius of each circle is the same, namely the value specified by the radius parameter passed to <span class="textVar">generateCircleDrop</span>.</p>
<p><span class="textVar">generateCircleDrop</span> returns an object of the form <span class="textVar">{points:array of Point,radii:array of number}</span>, specifying the successful drops. The algorithm terminates when <span class="textVar">dropTries</span> successive attempts at a drop fail.</p>


</div>
</div>
</body>
</html>



