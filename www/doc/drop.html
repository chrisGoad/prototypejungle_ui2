<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="description" content="Diagramming basedd on an open repository of prototype structures.">
<title>PrototypeJungle</title>
<link rel="stylesheet" type="text/css"  href="style.css"/>
<link rel="stylesheet" type="text/css"  href="spectrum.css"/>
<link rel="icon" href="/images/favicon.ico" />

<style>
	.theGrid {
		display:grid;
		padding-top:10px;
		grid-template-columns:1fr 4fr 1fr;
	}
  .indent {
		padding-left:20px;
	}
  .codeVar {
		font-style:italic;
	}  
  
  .textVar {
		font-weight:bold;
    font-size:12pt
	}
  .title {
		font-weight:bold;
    font-size:16pt;
    text-align:center;
	}
 .section {
		font-weight:bold;
    font-size:14pt;
	}
</style>
</head>
<body style="background-color:white;font-size:14pt"> 
<div class="theGrid">
<div></div>
<div>

<p> This module will be introduced via annotated code, which generates the image</p>
 <p><img  src="/doc/drop_ice.jpg?alt=media" style="bborder:thin black solid;cursor:pointer"  width="400" height="400" max-height="500"/></p>
 <p>Here's the code:</p>
<pre style="padding-left:20px;font-size:10pt;font-weight:bold" class="code">

import {rs as linePP} from '/line/line.mjs';
import {rs as basicsP} from '/generators/basics.mjs';
import {rs as addDropMethods} from '/mlib/drop.mjs';
import {rs as addSegsetMethods} from '/mlib/segsets.mjs';
let rs = basicsP.instantiate();

addDropMethods(rs);
addSegsetMethods(rs);
rs.setName('drop_ice');
let wd = 200;

let topParams = {width:wd,height:wd,dropTries:100,lineLength:2,frameStroke:'rgb(2,2,2)',framePadding:20,frameVisible:0,minSeparation:10}

Object.assign(rs,topParams);


rs.initProtos = function () {
	this.lineP = linePP.instantiate();
	this.lineP.stroke = 'yellow';
	this.lineP['stroke-width'] = .3;
}  

rs.initialDrop= function () {
  let {width,height} = this; 
  // the rectangleSegments method is defined in the segsets module
  let segs = this.rectangleSegments(width,height);
  let lines = segs.map((sg) => this.genLine(sg));  
  return [segs,lines];
}

rs.segParams = function () {
  let r = Math.random();
  let np = 4;
  let angle = Math.floor(r*np)* (Math.PI/np)
  let length = 2 + Math.floor(r*np)*4;
  return {angle,length};
} 

rs.dropAt = function (p) {
  let {minSeparation:sep,lineP} = this;
  let {length,angle} = this.segParams();
  let seg = this.genSegment(p,length,angle);
  let ln = this.genLine(seg,lineP);
  let eseg = this.genSegment(p,length+sep,angle);
  return [[eseg],[ln]];
}
 

rs.initialize = function () {
  core.root.backgroundColor = 'black';
	this.initProtos();
	this.generateDrop();
  	this.addFrame();

}

export {rs};


</pre>
<p> The DROP algorithm drops  things at random positions on the canvas. If a thing lands on top of another, it is thrown away, otherwise it is added.   I have used the vague word "thing". A thing is a pair [lineSegments,shapes], called a dropStruct. Often, but not always, the shapes are lines that  correspond directly to the segments in that they have the same ends; that is, they coincide geometrically. The operation</p>
<precode>
rs.segsToDropStruct = function (segs,lineP) {
  return [segs,segs.map((seg) => this.genLine(seg,LineP)]
]
</precode>

<p> will convert an array of segments into a dropStruct where this exact correspondence holds.</p> 
 
<p> As I say, lineSegments are used for detecting collisions. If a given drop does not intersect with the lineSegments already dropped, then the shapes are displayed (by adding them to the shape tree).
 The segsets method library is used to build sets of segments. </p>

<p>In an image generator, the  method: </p>
<preUserDefinedCode>
rs.dropAt = function (p) {
...
  return [segs,shapes];
}
</precode>
<p>should be defined, where p is a Point (the "anchor point"). rs.generateDrop will call rs.dropAt  on randomly generated points p within the canvas.  </p>

<p>Parameters: rs.dropTries sets how many unsuccessful drops are tolerated before the algorithm is terminated. </p>

<p> The DROP algorithm has another mode of operation, which is deployed when the top parameter fromEnds is set.</p>

<p>In fromEnds mode, segments are dropped in such a way as to extend an already existing tree. In this mode, illustrated by the dandelion image just below, the current state consists of a tree of segments. Each segment in the tree is either interior, meaning that its end1 has been continued by one or more segments, or terminal, meaning that there is no continuing segment emerging from its end1.</p>
 <p><img  src="/doc/drop_dandelion.jpg?alt=media" style="bborder:thin black solid;cursor:pointer"  width="400" height="400" max-height="500"/></p>

<p> Here is the code:</p>
<precode>
import {rs as linePP} from '/shape/line.mjs';
import {rs as basicP} from '/generators/basics.mjs';
import {rs as addDropMethods} from '/mlib/drop.mjs';
import {rs as addSegsetMethods} from '/mlib/segsets.mjs';
import {rs as addRandomMethods} from '/mlib/boundedRandomGrids.mjs';

let rs = basicP.instantiate();
addDropMethods(rs);
addRandomMethods(rs);
addSegsetMethods(rs);
addRandomMethods(rs);

rs.setName('drop_dandelion');
let ht = 360;
let wd = 1* ht;




let topParams = {width:wd,height:ht,framePadding:0.15*ht,
//parameters to performDrop
dropTries:10,maxDrops:Infinity,fromEnds:1,doNotExit:[geom.Circle.mk(Point.mk(0,0),0.5*ht)],
//parameters to genSegmentsFan
lineLength:5,fromEnds:1,extendWhich:'first',sepNext:0.01,splitChance:.40,splitAmount:0.05 *Math.PI,
directionChange:0.0*Math.PI,randomDirectionChange:0.025*Math.PI,lineExt:0,
// parameters to ringSeeds
numSeeds:15};

Object.assign(rs,topParams);

rs.initProtos = function () {
  this.lineP = linePP.instantiate();
  this.lineP.stroke = 'white';
  this.lineP['stroke-width'] = .5;
}  

rs.segParams = function () {
  let r = Math.random();
  let np = 4;
  let angle = Math.floor(r*np)* (Math.PI/np)
  let length = 2 + Math.floor(r*np)*4;
  return {angle,length};
}

rs.genSeeds = function () {
  debugger;
  let {width,lineP} = this;
  this.ringRadius = 0.15 * 0.5 * width;
  return this.ringSeeds(lineP,'transparent');  
}

rs.genDropStruct = function (p) {
  return this.genFan(this.lineP,p,'white',topParams);
}

rs.initialize = function () {
  
  this.initProtos();
  this.addFrame();
  this.generateDrop();
}

export {rs};
</precode>
</div>
</div>
</body>
</html>



