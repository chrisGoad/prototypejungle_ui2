{{boilerplate_kop}}
<div>
<p class="title">The grid module</p>

</pre><p>A user-defined JavaScript function, <span class="userDefinedText">shapeGenerator(gridCoordinates:Point,randomValues:Object)</span>  returns a shape,  based on the grid coordinates at which the shape is to be drawn, and an optional vector of random values which have been computed for that point by a smooth bounded random value generator. This generator, given max, min, and step parameters for each member of the vector, computes values for each grid point which differ from neighbors by no more than step, and which lie within the given min and max values. THus grid images can be generated populated by arbitrary shapes, whose attributes can be made to vary smoothly over the grid. 
need explanation. First, <span class="textVar">pointJiggle</span>, if defined and non-zero, causes the points of the grid to be displaced by  bounded and smoothly varying amounts. Details are <a href="boundedRandomGrids.html#jiggle">here</a>. </p> <!-- if defined and non-zero, causes
 two bounded grids to be setup via <span class="textVar"><a href="boundedRandomGrids.html">setupRandomGridForBoundaries</a></span>, named <span class="textVar">xJiggle</span> and <span class="textVar">yJiggle</span>. Then the points in the grid are jiggled by the amounts specified in those bounded grids. The maximum amount of jiggle is given by the <span class="textVar">pointJiggle</span> parameter. Since the grids are bounded, the amount of jiggle varies smoothly across the grid. Instead of pointJiggle, jiggleParams may be specified instead as in</p>
 <pre style="padding-left:20px;font-size:10pt;font-weight:bold" class="code">
 let topParams = {...jiggleParams:{step:1,min:-5,max:5}...};
</pre>-->
<p>
Next, the frame parameters:  the frame facility, which draws the white rectangle around the grid, is defined in the  <a href="basics.html">basics module</a>.</p>
<p> It is possible to modify the placement of grid points by defining <span class="userDefinedText">positionMethod(i,j)</span> where <span class="textVar">i</span> is the index of the current cell in the x (width) direction,
and <span class="textVar">j</span> is its index in the y (height) direction. Here is an example:</p>

 <p><img src="https://kingdomofpattern.com/thumbs/grid_example2.jpg" style="cursor:pointer"  width="300" height="300"/></p>
<p>and the code that produced it. Have a look at the <span class="userDefinedText">positionMethod</span> - the other operations we've seen before.
<pre style="padding-left:20px;font-size:10pt;font-weight:bold" class="code">
import {rs as basicsP} from '/generators/basics.mjs';
import {rs as addGridMethods} from '/mlib/grid.mjs';

let rs = basicsP.instantiate();
addGridMethods(rs);
rs.setName('grid_example2');
	
rs.initProtos = function () {
  rs.blineP  = linePP.instantiate();
  rs.blineP['stroke-width'] = 0.4;
  rs.blineP.stroke = 'white';

}  

let nr = 32;
let wd = 200;
let topParams = {numRows:nr,numCols:nr,width:wd,height:wd};
Object.assign(rs,topParams);

rs.positionMethod = function(i,j) {
  let {width,height,numRows,numCols} = this;
  let cellht = height/numRows;
  let cellwd = width/numCols;
  let frd = i/numRows;  //fraction down
  let cwd = frd*width; // current width
  let ccellwd = frd*cellwd; // currect width of a cell
  let rs = Point.mk(-0.5*cwd + j*ccellwd,-0.5* height + i*cellht);;
  return rs;
 }

rs.boundaryLineGenerator= function (end0,end1,rvs,cell) {
	let {blineP,numRows,showMissing,lines,updating,lineIndex} =this;
	let line = blineP.instantiate().show();
  line.setEnds(end0,end1);
	return line;
}


rs.initialize = function () {
  debugger;
  this.initProtos();
  this.generateGrid();
}



export {rs};
</pre>

<p>Several position functions are provided as part of the grid module.  The first is the default position function, which builds the usual sort of rectangular grid, and is installed as the initial positionMethod. The second is <span class="textVar">sidesPositionFunction</span>, in which the endpoints of  the "horizontal" (same y index)  lines are placed at even intervals on two sides, <span class="textVar">sideA</span>, and <span class="textVar">sideB</span>. 
For example the following code yields the same grid as shown immediately above.</p>

<pre style="padding-left:20px;font-size:10pt;font-weight:bold" class="code">

let topParams = 
{numRows:nr,numCols:nr,width:wd,height:ht,framePadding:0.1*wd,
 sideA:geom.LineSegment.mk(Point.mk(0,-0.5*ht),Point.mk(-0.5*wd,0.5*ht)),
 sideB:geom.LineSegment.mk(Point.mk(0,-0.5*ht),Point.mk(0.5*wd,0.5*ht))
};
Object.assign(rs,topParams);

rs.positionMethod = rs.sidesPositionMethod;
</pre>

<p>in <span class="textVar">sidesPositionMethod</span>, <span class="textVar">sideA</span> and <span class="textVar">sideB</span> can also be defined by functions which take a real input in the interval [0,1] and return a point on the plane. This allows the sides to be defined as arbitrary computable curves. For example, yet another way of producing
 the above grid is:
 <pre style="padding-left:20px;font-size:10pt;font-weight:bold" class="code">

 let topParams = 
{numRows:nr,numCols:nr,width:wd,height:ht,framePadding:0.1*wd,
 leftSide:geom.LineSegment.mk(Point.mk(0,-0.5*ht),Point.mk(-0.5*wd,0.5*ht)),
 rightSide:geom.LineSegment.mk(Point.mk(0,-0.5*ht),Point.mk(0.5*wd,0.5*ht)),
 sideA:function(fr) {return this.leftSide.pointAlong(fr)},
 sideB:function(fr) {return this.rightSide.pointAlong(fr)}};
Object.assign(rs,topParams);
rs.positionMethod = rs.sidesPositionMethod;
</pre>

<p>If <span class="textVar">rs.genPoint3d</span> of type
 <span class="textVar"><a href="/doc/geometry.html#Point">Point</a>=><a href="/doc/geometry.html#Point3d">Point3d</a></span> is defined, 
then the points on the grid (which may have been generated by a custom <span class="textVar">positionMethod</span>) are mapped  via</p>
 <pre style="padding-left:20px;font-size:10pt;font-weight:bold" class="code">
this.points = this.points.map((p) => this.camera.project(this.genPoint3d(p)))
 </pre>
 
<p>Of course it is necessary to define <a href="/doc/geometry.html#Camera">rs.camera</a>.</p>

</div>
</div>
</body>
</html>



